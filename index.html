<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Thank you — Onboarding</title>
  <style>
    :root { color-scheme: dark; /* Safe-area CSS variables for iOS/Android notches & home indicator */ --sat: env(safe-area-inset-top, 0px); --sar: env(safe-area-inset-right, 0px); --sab: env(safe-area-inset-bottom, 0px); --sal: env(safe-area-inset-left, 0px); }
    html, body { height: 100%; }
    html, body { margin: 0; padding: 0; background: #000; color: #fff; }
    body { font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Inter", "Segoe UI", Roboto, Arial, sans-serif; touch-action: manipulation; overscroll-behavior-y: none; -webkit-tap-highlight-color: rgba(0,0,0,0); }
    canvas { display: block; }
    /* Buttons drawn on canvas, but we use this for any off-canvas a11y helpers later. */
    .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
  </style>
</head>
<body>
  <main id="p5-holder"></main>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script>
  // ===============================================================
  // p5.js single-file onboarding for the “Thank you” installation
  // Theme: Black background, white type, modern Apple-like minimal design
  // Interactions: tap / click Next, swipe left/right, or use ← → keys
  // How to customize: edit the `slides` array below
  // Hook the final button via onBegin() to open your capture UI or URL
  // Safe-area aware: respects iOS/Android browser chrome using CSS env() insets
  // ===============================================================

  const slides = [
    { tag: 'intro', kicker: 'Welcome', title: 'Thank you.', subtitle: 'A participatory time capsule', body: 'Write a note of gratitude to someone compassionate in your life. All notes will be opened in 2035.' },
    { tag: 'why-1', kicker: 'Why this', title: 'Self as event.', body: 'Let us rediscover self as an event, as emergent from co‑created interbecoming. Hold this thought as you write.' },
    { tag: 'how-1', kicker: 'Step 1', title: 'Arrive & breathe.', body: 'Pick up a card at the writing station. Think of someone whose compassion changed you. A single moment is enough.' },
    { tag: 'how-2', kicker: 'Step 2', title: 'Write your note.', body: 'In 2–5 lines, say thank you. Note a detail that gives context to this historical moment. Sign your name if you like. When you are done, tap ’Next.’' },
    { tag: 'how-3', kicker: 'Step 3', title: 'Seal for 2035.', body: 'Fold and place your note in the envelope to seal your handwritten time‑capsule. Optionally, add the recipient’s name on the outside. When you are done, tap ’Next.’' },
    { tag: 'how-3', kicker: 'Step 3', title: 'Seal for 2035.', body: 'Below the recipient’s name, write ’To be opened in 2035.’ When you are done, tap ’Next.’},
    { tag: 'why-2', kicker: 'A shared practice', title: 'Interbecoming.', body: 'In Thank you, we become—together. Relief in motion from the vertiginous and distributed condition of being; a gaze into Mystery holding in our hearts the destiny of the ’other.’' },
    { tag: 'go-1', kicker: 'Gift it.', title: 'Show your gratitude.', body: 'If the person you are thanking is here at the conference, hand them your note. Tell them a summary of your appreciation for them. Then tell them to only open the note in 2035.' }
  ];

  // --- Appearance toggles ---
  const ACCENT_OPACITY = 220; // 0–255 white accents
  let ui = {
    margin: 28,
    maxWidth: 780,
    lineHeight: 1.4,
    dotSize: 8,
    dotGap: 10,
    buttonH: 52,
    buttonR: 14,
    bottomPad: 24 // extra breathing room above safe-bottom in pixels
  };

  let state = {
    i: 0,
    animT: 1,      // 0→1 for slide-in
    animV: 0,      // velocity for easing
    touchStartX: null,
    touchStartY: null,
    touchStartTime: 0,
  };

  // --- Typography scale computed from viewport ---
  function typeScale() {
    const base = min(windowWidth, windowHeight);
    const t = {
      kicker: max(12, round(base * 0.018)),
      title: max(26, round(base * 0.06)),
      body: max(14, round(base * 0.022)),
      hint: max(11, round(base * 0.017)),
      button: max(14, round(base * 0.022))
    };
    return t;
  }

  // --- Helpers ---
  function clamp(v, lo, hi) { return max(lo, min(hi, v)); }
  function easeOutCubic(x){ return 1 - pow(1 - x, 3); }

  // Read CSS safe-area insets (iOS/Android notch/home indicator)
  function readSafeInsets(){
    const cs = getComputedStyle(document.documentElement);
    const n = (prop) => parseFloat(cs.getPropertyValue(prop)) || 0;
    return { top: n('--sat'), right: n('--sar'), bottom: n('--sab'), left: n('--sal') };
  }

  function next() { if (state.i < slides.length - 1) changeTo(state.i + 1); }
  function prev() { if (state.i > 0) changeTo(state.i - 1); }
  function changeTo(n) { state.i = clamp(n, 0, slides.length - 1); state.animT = 0; state.animV = 0; }

  function onBegin() {
    // TODO: Replace with your capture UI or URL
    // e.g., window.location.href = 'capture.html';
    console.log('Begin tapped — hook up your capture flow here.');
  }

  // --- p5 setup/draw ---
  function setup() {
    const c = createCanvas(windowWidth, windowHeight);
    c.parent('p5-holder');
    pixelDensity(window.devicePixelRatio || 1);
    textFont('system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Inter", "Segoe UI", Roboto, Arial, sans-serif');
    textAlign(LEFT, TOP);
    noStroke();
  }

  function windowResized(){ resizeCanvas(windowWidth, windowHeight); }

  function draw() {
    background(0);

    // animate slide-in
    state.animT = clamp(state.animT + (1 - state.animT) * 0.16 + 0.0001, 0, 1);
    const a = easeOutCubic(state.animT);

    const t = typeScale();
    const safe = readSafeInsets();
    const margin = ui.margin;

    // Respect left/right safe-area to avoid curved corners/notches in landscape
    const cw = min(ui.maxWidth, width - (margin * 2 + safe.left + safe.right));
    const x = (width - cw) / 2;

    // content positions
    const topY = margin + safe.top + 8;

    // current slide
    const s = slides[state.i];

    // reset button hitboxes for this frame
    window._buttons = [];

    // Subtle slide-in translate
    push();
    translate(0, (1 - a) * 20);

    // Kicker
    fill(255, ACCENT_OPACITY);
    textSize(t.kicker);
    textStyle(NORMAL);
    textWrap(WORD);
    text(s.kicker || '', x, topY, cw);

    // Title
    fill(255);
    textSize(t.title);
    textStyle(BOLD);
    const titleY = topY + (s.kicker ? t.kicker + 10 : 0);
    text(s.title || '', x, titleY, cw);

    // Subtitle (only on intro)
    let bodyStart = titleY + t.title + 14;
    if (s.subtitle) {
      textStyle(NORMAL);
      textSize(t.body);
      fill(255, 220);
      text(s.subtitle, x, bodyStart, cw);
      bodyStart += t.body + 10;
    }

    // Body
    textStyle(NORMAL);
    textSize(t.body);
    fill(255, 210);
    textLeading(round(t.body * ui.lineHeight));
    text(s.body || '', x, bodyStart, cw);

    pop();

    // Bottom layout that never hides behind phone UI
    const yButtons = height - (safe.bottom + ui.bottomPad + ui.buttonH);
    const yDots    = yButtons - 20;                  // above buttons
    const yHints   = yDots - (t.hint + 12);          // above dots

    // Progress dots
    drawDots(x, yDots, cw, t);

    // Hints
    drawHints(x, yHints, cw, t);

    // Buttons
    drawNavButtons(x, yButtons, cw, t);
  }

  function drawDots(x, y, w, t) {
    const n = slides.length;
    const totalW = n * ui.dotSize + (n - 1) * ui.dotGap;
    const sx = x + (w - totalW) / 2;
    for (let i = 0; i < n; i++) {
      const isActive = i === state.i;
      const alpha = isActive ? 255 : 130;
      fill(255, alpha);
      circle(sx + i * (ui.dotSize + ui.dotGap) + ui.dotSize / 2, y, isActive ? ui.dotSize + 2 : ui.dotSize);
    }
  }

  function drawHints(x, y, w, t){
    fill(255, 150);
    textAlign(CENTER, TOP);
    textSize(t.hint);
    const hint = 'Tap left = Back • Tap right = Next • Swipe • ← / →';
    text(hint, x, y, w);
    textAlign(LEFT, TOP);
  }

  function drawNavButtons(x, y, w, t){
    const bw = 120;

    // Back (left)
    if (state.i > 0) {
      drawButton(x, y, bw, ui.buttonH, 'Back', () => prev());
    }

    // Next or Begin (right)
    const label = (state.i === slides.length - 1) ? 'Begin' : 'Next';
    drawButton(x + w - bw, y, bw, ui.buttonH, label, () => {
      if (state.i === slides.length - 1) onBegin(); else next();
    });
  }

  function drawButton(bx, by, bw, bh, label, onClick){
    // Outline pill
    const mx = mouseX, my = mouseY;
    const over = mx >= bx && mx <= bx + bw && my >= by && my <= by + bh;

    push();
    stroke(255, over ? 255 : 200);
    strokeWeight(1.2);
    noFill();
    rect(bx, by, bw, bh, ui.buttonR);

    // Label
    noStroke();
    fill(255, over ? 255 : 230);
    textAlign(CENTER, CENTER);
    textSize(typeScale().button);
    text(label, bx + bw/2, by + bh/2 + 1);
    textAlign(LEFT, TOP);
    pop();

    // Store for click detection each frame
    if (!window._buttons) window._buttons = [];
    window._buttons.push({ bx, by, bw, bh, onClick });
  }

  // --- input ---
  function mousePressed(){ state.touchStartX = mouseX; state.touchStartY = mouseY; state.touchStartTime = millis(); }
  function mouseReleased(){
    // 1) Button clicks take priority
    const list = window._buttons || [];
    for (const b of list) {
      if (mouseX >= b.bx && mouseX <= b.bx + b.bw && mouseY >= b.by && mouseY <= b.by + b.bh) {
        b.onClick();
        window._buttons = [];
        return;
      }
    }
    window._buttons = [];

    // 2) Swipe detection (dominates over tap zones)
    const dx = mouseX - (state.touchStartX ?? mouseX);
    const dy = mouseY - (state.touchStartY ?? mouseY);
    const dt = millis() - (state.touchStartTime || millis());
    const absDx = Math.abs(dx), absDy = Math.abs(dy);

    if (dt < 700 && absDx > 40 && absDx > absDy) {
      if (dx < 0) next(); else prev();
      return;
    }

    // 3) Tap zones: left = Back, right = Next/Begin
    const isTap = (dt < 500) && (dist(mouseX, mouseY, state.touchStartX ?? mouseX, state.touchStartY ?? mouseY) < 10);
    if (isTap) {
      if (mouseX < width / 2) {
        prev();
      } else {
        if (state.i === slides.length - 1) onBegin(); else next();
      }
    }
  }

  // Touch aliases so iOS/Android fire the same logic
  function touchStarted(){ mousePressed(); return false; }
  function touchEnded(){ mouseReleased(); return false; }

  function keyPressed(){
    if (keyCode === RIGHT_ARROW) next();
    if (keyCode === LEFT_ARROW) prev();
    if (key === 'Enter' || key === ' ') {
      if (state.i === slides.length - 1) onBegin(); else next();
    }
  }

  // Expose p5 lifecycle
  window.setup = setup;
  window.draw = draw;
  window.windowResized = windowResized;
  window.mousePressed = mousePressed;
  window.mouseReleased = mouseReleased;
  window.keyPressed = keyPressed;
  </script>
</body>
</html>
