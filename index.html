<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Thank you — Onboarding</title>
  <style>
    :root { color-scheme: dark; --sat: env(safe-area-inset-top,0); --sar: env(safe-area-inset-right,0); --sab: env(safe-area-inset-bottom,0); --sal: env(safe-area-inset-left,0); }
    html, body { height: 100%; margin: 0; padding: 0; background: #000; color: #fff; }
    body { font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Inter", "Segoe UI", Roboto, Arial, sans-serif; touch-action: manipulation; overscroll-behavior-y: none; -webkit-tap-highlight-color: transparent; }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
  <main id="p5-holder"></main>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script>
    const slides = [
      { tag: 'intro', kicker: 'Welcome', title: 'Thank you.', subtitle: 'A participatory time capsule', body: 'Write a note of gratitude to someone compassionate in your life. All notes will be opened in 2035.' },
      { tag: 'why-1', kicker: 'Why this', title: 'Self as event.', body: 'Let us rediscover self as an event—emergent from co-created interbecoming. Hold this thought as you write.' },
      { tag: 'how-1', kicker: 'Step 1', title: 'Arrive & breathe.', body: 'Pick up a card at the writing station. Think of someone whose compassion changed you. A single moment is enough.' },
      { tag: 'how-2', kicker: 'Step 2', title: 'Write your note.', body: 'In 2–5 lines, say thank you. Include a concrete detail that best encapsulates your relationship with them in this moment in time. Sign your name if you like.' },
      { tag: 'how-3', kicker: 'Step 3', title: 'Seal for 2035.', body: 'Fold and place your note in the envelope and seal your handwritten time-capsule. Optionally, add the recipient’s name on the outside.' },
      { tag: 'why-2', kicker: 'A shared practice', title: 'Interbecoming.', body: 'In Thank you, we become—together. Relief in motion from the vertiginous and distributed condition of being, by gazing into Mystery and holding in our hearts the destiny of the other.' },
      { tag: 'begin', kicker: 'You are ready', title: 'Begin?', body: 'Tap Begin to add your note. You can also use the ← → keys or swipe to review instructions.' }
    ];

    const ACCENT_OPACITY = 220;
    let ui = { margin: 28, maxWidth: 780, lineHeight: 1.4, dotSize: 8, dotGap: 10, buttonH: 52, buttonR: 14, bottomPad: 24 };
    let state = { i: 0, animT: 1, animV: 0, touchStartX: null, touchStartY: null, touchStartTime: 0, touchMoved: false };

    function typeScale() {
      const base = min(windowWidth, windowHeight);
      return {
        kicker: max(12, round(base * 0.018)),
        title: max(26, round(base * 0.06)),
        body: max(14, round(base * 0.022)),
        hint: max(11, round(base * 0.017)),
        button: max(14, round(base * 0.022))
      };
    }

    function clamp(v, lo, hi) { return max(lo, min(hi, v)); }
    function easeOutCubic(x){ return 1 - pow(1 - x, 3); }
    function readSafeInsets(){
      const cs = getComputedStyle(document.documentElement);
      const n = (prop) => parseFloat(cs.getPropertyValue(prop)) || 0;
      return { top: n('--sat'), right: n('--sar'), bottom: n('--sab'), left: n('--sal') };
    }

    function next() { if (state.i < slides.length - 1) changeTo(state.i + 1); }
    function prev() { if (state.i > 0) changeTo(state.i - 1); }
    function changeTo(n) { state.i = clamp(n, 0, slides.length - 1); state.animT = 0; state.animV = 0; }
    function onBegin() { console.log('Begin tapped — hook up your capture flow here.'); }

    function setup() {
      createCanvas(windowWidth, windowHeight).parent('p5-holder');
      pixelDensity(window.devicePixelRatio || 1);
      textFont('system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Inter", "Segoe UI", Roboto, Arial, sans-serif');
      textAlign(LEFT, TOP);
      noStroke();
    }

    function windowResized(){ resizeCanvas(windowWidth, windowHeight); }

    function draw() {
      background(0);
      state.animT = clamp(state.animT + (1 - state.animT) * 0.16 + 0.0001, 0, 1);
      const a = easeOutCubic(state.animT);
      const t = typeScale();
      const safe = readSafeInsets();
      const cw = min(ui.maxWidth, width - (ui.margin * 2 + safe.left + safe.right));
      const x = (width - cw) / 2;
      const topY = ui.margin + safe.top + 8;
      const s = slides[state.i];
      window._buttons = [];

      push();
      translate(0, (1 - a) * 20);
      fill(255, ACCENT_OPACITY);
      textSize(t.kicker);
      textStyle(NORMAL);
      textWrap(WORD);
      text(s.kicker || '', x, topY, cw);

      fill(255);
      textSize(t.title);
      textStyle(BOLD);
      const titleY = topY + (s.kicker ? t.kicker + 10 : 0);
      text(s.title || '', x, titleY, cw);

      let bodyStart = titleY + t.title + 14;
      if (s.subtitle) {
        textStyle(NORMAL);
        textSize(t.body);
        fill(255, 220);
        text(s.subtitle, x, bodyStart, cw);
        bodyStart += t.body + 10;
      }

      textStyle(NORMAL);
      textSize(t.body);
      fill(255, 210);
      textLeading(round(t.body * ui.lineHeight));
      text(s.body || '', x, bodyStart, cw);
      pop();

      const yButtons = height - (safe.bottom + ui.bottomPad + ui.buttonH);
      const yDots = yButtons - 20;
      const yHints = yDots - (t.hint + 12);

      drawDots(x, yDots, cw);
      drawHints(x, yHints, cw, t);
      drawNavButtons(x, yButtons, cw, t);
    }

    function drawDots(x, y, w) {
      const n = slides.length;
      const totalW = n * ui.dotSize + (n - 1) * ui.dotGap;
      const sx = x + (w - totalW) / 2;
      for (let i = 0; i < n; i++) {
        const isActive = i === state.i;
        fill(255, isActive ? 255 : 130);
        circle(sx + i * (ui.dotSize + ui.dotGap) + ui.dotSize / 2, y, isActive ? ui.dotSize + 2 : ui.dotSize);
      }
    }

    function drawHints(x, y, w, t){
      fill(255, 150);
      textAlign(CENTER, TOP);
      textSize(t.hint);
      text('Tap left = Back • Tap right = Next • Swipe • ← / →', x, y, w);
      textAlign(LEFT, TOP);
    }

    function drawNavButtons(x, y, w, t){
      const bw = 120;
      if (state.i > 0) {
        drawButton(x, y, bw, ui.buttonH, 'Back', () => prev());
      }
      const isBeginSlide = slides[state.i].tag === 'begin';
      const label = (isBeginSlide || state.i === slides.length - 1) ? 'Begin' : 'Next';
      drawButton(x + w - bw, y, bw, ui.buttonH, label, () => {
        if (isBeginSlide || state.i === slides.length - 1) onBegin(); else next();
      });
    }

    function drawButton(bx, by, bw, bh, label, onClick){
      const over = mouseX >= bx && mouseX <= bx + bw && mouseY >= by && mouseY <= by + bh;
      push();
      stroke(255, over ? 255 : 200);
      strokeWeight(1.2);
      noFill();
      rect(bx, by, bw, bh, ui.buttonR);
      noStroke();
      fill(255, over ? 255 : 230);
      textAlign(CENTER, CENTER);
      textSize(typeScale().button);
      text(label, bx + bw/2, by + bh/2 + 1);
      textAlign(LEFT, TOP);
      pop();
      window._buttons.push({ bx, by, bw, bh, onClick });
    }

    function mousePressed(){ state.touchStartX = mouseX; state.touchStartY = mouseY; state.touchStartTime = millis(); state.touchMoved = false; }
    function mouseReleased(){
      for (const b of (window._buttons || [])) {
        if (mouseX >= b.bx && mouseX <= b.bx + b.bw && mouseY >= b.by && mouseY <= b.by + b.bh) { b.onClick(); return; }
      }
      const dx = mouseX - state.touchStartX;
      const dy = mouseY - state.touchStartY;
      const dt = millis() - state.touchStartTime;
      if (dt < 700 && Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) { if (dx < 0) next(); else prev(); return; }
      const isTap = (dt < 500) && !state.touchMoved && dist(mouseX, mouseY, state.touchStartX, state.touchStartY) < 10;
      if (isTap) { if (mouseX < width / 2) prev(); else (state.i === slides.length - 1 || slides[state.i].tag === 'begin') ? onBegin() : next(); }
    }
    function touchStarted(){ mousePressed(); return false; }
    function touchEnded(){ mouseReleased(); return false; }
    function touchMoved(){ state.touchMoved = true; return false; }
    function keyPressed(){
      if (keyCode === RIGHT_ARROW) next();
      if (keyCode === LEFT_ARROW) prev();
      if (key === 'Enter' || key === ' ') (state.i === slides.length - 1 || slides[state.i].tag === 'begin') ? onBegin() : next();
    }

    window.setup = setup;
    window.draw = draw;
    window.windowResized = windowResized;
    window.mousePressed = mousePressed;
    window.mouseReleased = mouseReleased;
    window.keyPressed = keyPressed;
  </script>
</body>
</html>
